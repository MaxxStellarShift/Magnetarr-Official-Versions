import sys
import os
import tkinter as tk
from tkinter import scrolledtext, messagebox, simpledialog
from PIL import Image, ImageTk
import time
import threading
import requests
import json
from io import BytesIO
from google.oauth2.service_account import Credentials
from googleapiclient.discovery import build
from googleapiclient.http import MediaIoBaseUpload
from datetime import datetime

# Masquage de la console Windows
if sys.platform == "win32":
    try:
        import ctypes
        import ctypes.wintypes
        # Pour masquer la fenêtre de console
        hwnd = ctypes.windll.kernel32.GetConsoleWindow()
        if hwnd != 0:
            ctypes.windll.user32.ShowWindow(hwnd, 0)  # SW_HIDE = 0
    except Exception:
        pass  # On ignore simplement si ça ne marche pas

# ===============================================
# MAIN CONFIG
# ===============================================

# Configuration Google Drive
SERVICE_ACCOUNT_FILE = r'AHAHAHAHAHAHAHHAHA'#<----Your path here----
DOSSIER_PARTAGE_ID = '1LvcEMS3ZehjGXYaJaHfNL907J8DyadYz' <----also Ask me for this-----

# Image de démarrage depuis Google Drive
IMAGE_DRIVE_ID = '1GZA_ekjQFhrsEj42oOv0AJE9ZKWIfqaC'

# Configuration des utilisateurs
USERS_JSON_FILE_ID = '1U7g4EHoVtDWT-luW4hEfBMt9IpjrXlKo'

# Dossier pour stocker les conversations
CONVERSATIONS_FOLDER_ID = '1t4bDpIvhgdwyaTqools0h6UqK417DoY_'

# Configuration des fichiers de conversation pré-créés
CONVERSATION_FILES = {
    "natllux_pulsaris quantica": "1w9bZYf0vj3iG4ojjwMlj22C9d3TVvwOu",
    "pulsaris quantica_natllux": "1w9bZYf0vj3iG4ojjwMlj22C9d3TVvwOu",
    # Possibilité d'ajouter des conv's
}

# Template du fichier users.json à créer :
"""
{
    "users": [
        {
            "username": "admin",
            "password": "admin123",
            "role": "admin",
            "email": "admin@magnetarr.com"
        },
        {
            "username": "pulsaris",
            "password": "motdepasse123",
            "role": "user",
            "email": "pulsaris@example.com"
        },
        {
            "username": "testuser",
            "password": "test456",
            "role": "user",
            "email": "test@example.com"
        }
    ]
}
"""

# ===============================================
# MAIN CLASSS
# ===============================================

class MagnetarrApp:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Initialisation...")
        self.root.configure(bg='black')
        self.root.resizable(False, False)
        
        # Paramètres de la fenêtre
        self.width, self.height = 800, 600
        
        # État de l'utilisateur
        self.current_user = None
        self.is_logged_in = False
        
        # Service Google Drive (sera initialisé au démarrage)
        self.drive_service = None
        
        # Variables pour le chat
        self.current_chat_user = None
        self.chat_history = []
        
        # Centrer la fenêtre
        self.center_window()
        
        # Variables pour gérer les animations et transitions
        self.start_time = time.time()
        self.duration = 9  # Durée totale : 5s d'intro + 4s d'outro
        self.fade_in_duration = 5  # 5 secondes d'apparition en fondu
        self.fade_out_duration = 4  # 4 secondes de disparition en fondu
        self.splash_finished = False
        self.current_alpha = 0.0
        
        # Interface principale
        self.main_frame = tk.Frame(self.root, bg='black')
        self.main_frame.pack(fill='both', expand=True)
        
        # Démarrer le programme
        self.start_splash_screen()
    
    def center_window(self):
        """Centrer la fenêtre sur l'écran"""
        self.root.update_idletasks()
        x = (self.root.winfo_screenwidth() // 2) - (self.width // 2)
        y = (self.root.winfo_screenheight() // 2) - (self.height // 2)
        self.root.geometry(f"{self.width}x{self.height}+{x}+{y}")

# ===============================================
# GESTION DE L'ÉCRAN DE DÉMARRAGE ET ANIMATIONS
# ===============================================

    def start_splash_screen(self):
        """Initialiser et démarrer l'écran de démarrage"""
        # Préparation du chargement d'image
        self.image_loaded = False
        self.photo = None
        
        # Zone d'affichage principale
        self.display_frame = tk.Frame(self.main_frame, bg='black')
        self.display_frame.pack(fill='both', expand=True)
        
        # Chargement de l'image en arrière-plan pour ne pas bloquer l'interface
        threading.Thread(target=self.load_splash_image, daemon=True).start()
        
        # Initialiser Google Drive en arrière-plan
        threading.Thread(target=self.initialize_drive_service, daemon=True).start()
        
        # Démarrer l'animation
        self.animate_splash()
    
    def initialize_drive_service(self):
        """Initialiser le service Google Drive"""
        try:
            print("🔄 Initialisation du service Google Drive...")
            scopes = ['https://www.googleapis.com/auth/drive']
            credentials = Credentials.from_service_account_file(SERVICE_ACCOUNT_FILE, scopes=scopes)
            self.drive_service = build('drive', 'v3', credentials=credentials)
            print("✅ Service Google Drive initialisé avec succès!")
        except Exception as e:
            print(f"❌ Erreur lors de l'initialisation de Google Drive: {e}")
            self.drive_service = None
    
    def load_splash_image(self):
        """Charger l'image depuis Google Drive"""
        try:
            print(f"🔄 Chargement de l'image de démarrage: {IMAGE_DRIVE_ID}")
            
            # URL de téléchargement direct depuis Google Drive
            url = f"https://drive.google.com/uc?export=download&id={IMAGE_DRIVE_ID}"
            
            # En-têtes pour éviter d'être bloqué par Google
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }
            
            response = requests.get(url, headers=headers, timeout=15)
            
            if response.status_code == 200:
                # Traitement de l'image téléchargée
                img_data = BytesIO(response.content)
                img = Image.open(img_data)
                
                # Ajustement de la taille pour s'adapter à la fenêtre
                img = img.resize((self.width, self.height), Image.Resampling.LANCZOS)
                
                # Conversion pour l'affichage avec tkinter
                self.photo = ImageTk.PhotoImage(img)
                
                # Affichage de l'image sur l'interface principale
                self.root.after(0, self.create_image_display)
                
                print("✅ Image de démarrage chargée avec succès!")
                
            else:
                print(f"❌ Erreur HTTP: {response.status_code}")
                self.root.after(0, self.create_fallback_splash)
                
        except Exception as e:
            print(f"❌ Erreur chargement image: {e}")
            self.root.after(0, self.create_fallback_splash)
    
    def create_image_display(self):
        """Créer l'affichage avec l'image"""
        if self.photo:
            # On nettoie affichage actuel
            for widget in self.display_frame.winfo_children():
                widget.destroy()
            
            # Création de l'affichage image
            self.image_label = tk.Label(
                self.display_frame, 
                image=self.photo, 
                bg='black'
            )
            self.image_label.pack(fill='both', expand=True)
            self.image_loaded = True
    
    def create_fallback_splash(self):
        """Créer l'affichage de secours stylé"""
        # On nettoie l'affichage pour mettre l'interface de secours
        for widget in self.display_frame.winfo_children():
            widget.destroy()
        
        # Interface de secours élégante quand l'image ne charge pas
        container = tk.Frame(self.display_frame, bg='black')
        container.pack(expand=True)
        
        # Logo et titre principal
        title = tk.Label(
            container,
            text="🚀 Magnetarr",
            font=("Arial", 32, "bold"),
            fg="#00bc64",
            bg='black'
        )
        title.pack(pady=(100, 10))
        
        subtitle = tk.Label(
            container,
            text="By Pulsaris Q.",
            font=("Arial", 18, "italic"),
            fg="#ffffff6c",
            bg='black'
        )
        subtitle.pack(pady=(0, 50))
        
        # Séparateur visuel stylé
        separator = tk.Label(
            container,
            text="━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━",
            font=("Arial", 12),
            fg='#444444',
            bg='black'
        )
        separator.pack(pady=20)
        
        # Indicateur de chargement
        init_msg = tk.Label(
            container,
            text="Initialisation en cours...",
            font=("Arial", 16),
            fg='#888888',
            bg='black'
        )
        init_msg.pack(pady=(20, 100))
        
        self.image_loaded = True  
    
    def animate_splash(self):
        """Animation principale avec fondu d'entrée et de sortie"""
        elapsed = time.time() - self.start_time
        
        # Gestion du timing de l'animation avec les différentes phases
        if elapsed < self.fade_in_duration:
            # L'image apparaît
            alpha = elapsed / self.fade_in_duration
        elif elapsed < (self.duration - self.fade_out_duration):
            # L'image reste visible un moment (transparence à 1)
            alpha = 1.0
        elif elapsed < self.duration:
            fade_progress = (elapsed - (self.duration - self.fade_out_duration)) / self.fade_out_duration
            alpha = 1.0 - fade_progress
        else:
            # Animation terminée, menu principal
            if not self.splash_finished:
                self.splash_finished = True
                self.show_main_menu()
            return
        
        # effets visuels selon la transparence
        self.apply_fade_effect(alpha)
        
        # Continuer l'animation
        self.root.after(50, self.animate_splash)
    
    def apply_fade_effect(self, alpha):
        """Appliquer l'effet de fondu"""
        if alpha != self.current_alpha:
            self.current_alpha = alpha
            
            # On ne change les couleurs que si nécessaire pour optimiser
            # Calcul de l'intensité : noir total vers un gris très sombre
            bg_intensity = int(alpha * 25)  # Intensité de 0 à 25 pour un effet subtil
            bg_color = f"#{bg_intensity:02x}{bg_intensity:02x}{bg_intensity:02x}"
            
            # Application des couleurs à toute l'interface
            self.root.configure(bg=bg_color)
            self.main_frame.configure(bg=bg_color)
            
            # On s'assure que la zone d'affichage a aussi les bonnes couleurs
            if hasattr(self, 'display_frame'):
                self.display_frame.configure(bg=bg_color)
                
                # Mise à jour récursive de tous les éléments visuels
                for widget in self.display_frame.winfo_children():
                    try:
                        if isinstance(widget, tk.Label):
                            widget.configure(bg=bg_color)
                        elif isinstance(widget, tk.Frame):
                            widget.configure(bg=bg_color)
                            # Appliquer récursivement aux enfants du frame
                            for child in widget.winfo_children():
                                if isinstance(child, (tk.Label, tk.Frame)):
                                    child.configure(bg=bg_color)
                    except tk.TclError:
                        pass  # Ignorer les widgets détruits

# ===============================================
# GESTION DES UTILISATEURS ET CONNEXION
# ===============================================

    def load_users_from_drive(self):
        """Charger les utilisateurs depuis Google Drive"""
        try:
            if not self.drive_service:
                print("❌ Service Google Drive non initialisé")
                return []
            
            print(f"🔄 Chargement des utilisateurs depuis Google Drive: {USERS_JSON_FILE_ID}")
            
            # Télécharger le fichier depuis Google Drive
            request = self.drive_service.files().get_media(fileId=USERS_JSON_FILE_ID)
            file_content = request.execute()
            
            # Décoder le contenu JSON
            users_data = json.loads(file_content.decode('utf-8'))
            users = users_data.get('users', [])
            
            print(f"✅ {len(users)} utilisateurs chargés depuis Google Drive")
            return users
                
        except Exception as e:
            print(f"❌ Erreur lors du chargement des utilisateurs depuis Google Drive: {e}")
            # Retourner des utilisateurs par défaut en cas d'erreur
            return [
                {
                    "username": "admin",
                    "password": "admin123",
                    "role": "admin",
                    "email": "admin@magnetarr.com"
                },
                {
                    "username": "pulsaris",
                    "password": "motdepasse123",
                    "role": "user",
                    "email": "pulsaris@example.com"
                },
                {
                    "username": "testuser",
                    "password": "test456",
                    "role": "user",
                    "email": "test@example.com"
                }
            ]
    
    def authenticate_user(self, username, password):
        """Authentifier un utilisateur"""
        users = self.load_users_from_drive()
        
        for user in users:
            if user['username'] == username and user['password'] == password:
                return user
        
        return None
    
    def show_login_dialog(self):
        """Afficher la boîte de dialogue de connexion"""
        # Vérifier si Google Drive est disponible
        if not self.drive_service:
            messagebox.showerror(
                "Erreur de connexion", 
                "Impossible de se connecter à Google Drive.\nVérifiez votre connexion internet et vos credentials."
            )
            return
        
        # Créer une fenêtre de connexion
        login_window = tk.Toplevel(self.root)
        login_window.title("🔑 Connexion à Magnetarr")
        login_window.configure(bg='#2d2d2d')
        login_window.resizable(False, False)
        login_window.geometry("400x300")
        
        # Centrer la fenêtre de connexion
        login_window.transient(self.root)
        login_window.grab_set()
        
        # Variables pour les champs
        username_var = tk.StringVar()
        password_var = tk.StringVar()
        
        # Titre
        title_label = tk.Label(
            login_window,
            text="🔑 Connexion",
            font=('Arial', 16, 'bold'),
            fg='#00ff88',
            bg='#2d2d2d'
        )
        title_label.pack(pady=(20, 30))
        
        # Champ nom d'utilisateur
        username_label = tk.Label(
            login_window,
            text="Nom d'utilisateur:",
            font=('Arial', 11),
            fg='#ffffff',
            bg='#2d2d2d'
        )
        username_label.pack(pady=(10, 5))
        
        username_entry = tk.Entry(
            login_window,
            textvariable=username_var,
            font=('Arial', 11),
            width=25,
            bg='#1a1a1a',
            fg='#ffffff',
            insertbackground='#ffffff',
            relief='flat',
            bd=5
        )
        username_entry.pack(pady=(0, 15))
        username_entry.focus()
        
        # Champ mot de passe
        password_label = tk.Label(
            login_window,
            text="Mot de passe:",
            font=('Arial', 11),
            fg='#ffffff',
            bg='#2d2d2d'
        )
        password_label.pack(pady=(0, 5))
        
        password_entry = tk.Entry(
            login_window,
            textvariable=password_var,
            font=('Arial', 11),
            width=25,
            show='*',
            bg='#1a1a1a',
            fg='#ffffff',
            insertbackground='#ffffff',
            relief='flat',
            bd=5
        )
        password_entry.pack(pady=(0, 20))
        
        # Zone des boutons
        button_frame = tk.Frame(login_window, bg='#2d2d2d')
        button_frame.pack(pady=20)
        
        def attempt_login():
            """Tentative de connexion"""
            username = username_var.get().strip()
            password = password_var.get().strip()
            
            if not username or not password:
                messagebox.showerror("Erreur", "Veuillez remplir tous les champs")
                return
            
            # Afficher un message de chargement
            login_btn.config(text="🔄 Connexion...", state='disabled')
            login_window.update()
            
            user = self.authenticate_user(username, password)
            
            if user:
                self.current_user = user
                self.is_logged_in = True
                login_window.destroy()
                self.show_main_menu()  # Rafraîchir le menu avec les nouveaux boutons
                messagebox.showinfo("Succès", f"Bienvenue, {user['username']} !")
            else:
                messagebox.showerror("Erreur", "Nom d'utilisateur ou mot de passe incorrect")
                password_entry.delete(0, tk.END)
                login_btn.config(text="🔑 Se connecter", state='normal')
        
        def cancel_login():
            """Annuler la connexion"""
            login_window.destroy()
        
        # Bouton Se connecter
        login_btn = tk.Button(
            button_frame,
            text="🔑 Se connecter",
            command=attempt_login,
            bg='#4488ff',
            fg='white',
            font=('Arial', 11, 'bold'),
            relief='flat',
            padx=20,
            pady=8
        )
        login_btn.pack(side='left', padx=10)
        
        # Bouton Annuler
        cancel_btn = tk.Button(
            button_frame,
            text="❌ Annuler",
            command=cancel_login,
            bg='#ff4444',
            fg='white',
            font=('Arial', 11, 'bold'),
            relief='flat',
            padx=20,
            pady=8
        )
        cancel_btn.pack(side='left', padx=10)
        
        # Permettre la connexion avec Entrée
        def on_enter(event):
            attempt_login()
        
        login_window.bind('<Return>', on_enter)
        password_entry.bind('<Return>', on_enter)
    
    def logout_user(self):
        """Déconnecter l'utilisateur"""
        self.current_user = None
        self.is_logged_in = False
        self.show_main_menu()  # Rafraîchir le menu
        messagebox.showinfo("Déconnexion", "Vous avez été déconnecté avec succès")

# ===============================================
# GESTION DU MENU PRINCIPAL
# ===============================================

    def show_main_menu(self):
        """Afficher le menu principal"""
        print("🔄 Affichage du menu principal...")
        
        # Nettoyer complètement le contenu actuel
        for widget in self.main_frame.winfo_children():
            widget.destroy()
        
        # Changer le titre de la fenêtre
        if self.is_logged_in:
            self.root.title(f"🚀 Magnetarr - Menu Principal ({self.current_user['username']})")
        else:
            self.root.title("🚀 Magnetarr - Menu Principal")
        
        # Créer l'interface du menu
        self.setup_main_menu()
    
    def setup_main_menu(self):
        """Créer l'interface du menu principal"""
        # === CONFIGURATION VISUELLE DU MENU ===
        # (Vous pouvez facilement modifier ces couleurs et styles)
        
        # Couleurs principales
        bg_color = '#1a1a1a'           # Fond principal
        header_color = '#2d2d2d'       # Couleur de l'en-tête
        accent_color = '#00ff88'       # Couleur d'accentuation (titre)
        text_color = '#ffffff'         # Couleur du texte
        button_login = '#4488ff'       # Bouton de connexion
        button_console = '#ff8844'     # Bouton Console
        button_logout = '#ff6666'      # Bouton de déconnexion
        button_discussion = '#88ff44'  # Bouton Discussion
        button_text = '#ffffff'        # Texte des boutons
        
        # Polices
        title_font = ('Arial', 16, 'bold')
        button_font = ('Arial', 12, 'bold')
        
        # === FIN CONFIGURATION VISUELLE ===
        
        # Application des couleurs de base
        self.root.configure(bg=bg_color)
        self.main_frame.configure(bg=bg_color)
        
        # En-tête avec titre
        header = tk.Frame(self.main_frame, bg=header_color, height=60)
        header.pack(fill='x', padx=10, pady=10)
        header.pack_propagate(False)
        
        if self.is_logged_in:
            title_text = f"🚀 ᴍᴀɢɴᴇᴛᴀʀʀ - Bienvenue {self.current_user['username']}"
        else:
            title_text = "🚀 ᴍᴀɢɴᴇᴛᴀʀʀ - Menu Principal"
        
        title_label = tk.Label(
            header,
            text=title_text,
            font=title_font,
            fg=accent_color,
            bg=header_color
        )
        title_label.pack(expand=True)
        
        # Zone centrale pour les boutons
        center_frame = tk.Frame(self.main_frame, bg=bg_color)
        center_frame.pack(expand=True, fill='both')
        
        # Container pour centrer les boutons
        button_container = tk.Frame(center_frame, bg=bg_color)
        button_container.pack(expand=True)
        
        # Boutons selon l'état de connexion
        if not self.is_logged_in:
            # Utilisateur non connecté
            # Bouton "Se connecter"
            connect_btn = tk.Button(
                button_container,
                text="🔑 Se connecter",
                command=self.show_login_dialog,
                bg=button_login,
                fg=button_text,
                font=button_font,
                relief='flat',
                width=25,
                height=2,
                cursor='hand2'
            )
            connect_btn.pack(pady=(50, 20))
            
            # Bouton "Console"
            console_btn = tk.Button(
                button_container,
                text="💻 Console",
                command=self.show_console,
                bg=button_console,
                fg=button_text,
                font=button_font,
                relief='flat',
                width=25,
                height=2,
                cursor='hand2'
            )
            console_btn.pack(pady=(0, 50))
            
        else:
            # Utilisateur connecté
            # Bouton "Se déconnecter"
            logout_btn = tk.Button(
                button_container,
                text="🚪 Se déconnecter",
                command=self.logout_user,
                bg=button_logout,
                fg=button_text,
                font=button_font,
                relief='flat',
                width=25,
                height=2,
                cursor='hand2'
            )
            logout_btn.pack(pady=(30, 20))
            
            # Bouton "Console"
            console_btn = tk.Button(
                button_container,
                text="💻 Console",
                command=self.show_console,
                bg=button_console,
                fg=button_text,
                font=button_font,
                relief='flat',
                width=25,
                height=2,
                cursor='hand2'
            )
            console_btn.pack(pady=(0, 20))
            
            # Bouton "Discussion" (maintenant fonctionnel)
            discussion_btn = tk.Button(
                button_container,
                text="💬 Discussion",
                command=self.show_discussion,
                bg=button_discussion,
                fg=button_text,
                font=button_font,
                relief='flat',
                width=25,
                height=2,
                cursor='hand2'
            )
            discussion_btn.pack(pady=(0, 30))
        
        # Footer avec informations
        footer = tk.Frame(self.main_frame, bg=header_color, height=40)
        footer.pack(fill='x', padx=10, pady=(0, 10))
        footer.pack_propagate(False)
        
        footer_label = tk.Label(
            footer,
            text="By Pulsaris Quantica | Version beta 1.1",
            font=('Arial', 10),
            fg='#888888',
            bg=header_color
        )
        footer_label.pack(expand=True)
        
        # Bouton fermer dans le coin
        close_btn = tk.Button(
            footer,
            text="❌",
            command=self.on_closing,
            bg='#ff4444',
            fg='white',
            font=('Arial', 8, 'bold'),
            relief='flat',
            width=3,
            height=1
        )
        close_btn.pack(side='right', padx=5, pady=5)

# ===============================================
# GESTION DE LA MESSAGERIE ET CONVERSATIONS
# ===============================================

    def get_conversation_file_id(self):
        """Obtenir l'ID du fichier de conversation pour les deux utilisateurs"""
        # Créer la clé de recherche (noms triés et en minuscules)
        users = sorted([self.current_user['username'].lower(), self.current_chat_user['username'].lower()])
        search_key = f"{users[0]}_{users[1]}"
        
        # Chercher dans notre dictionnaire
        file_id = CONVERSATION_FILES.get(search_key)
        
        if file_id:
            print(f"✅ Fichier de conversation trouvé: {search_key} -> {file_id}")
            return file_id
        else:
            print(f"❌ Aucun fichier de conversation configuré pour: {search_key}")
            print("📋 Fichiers disponibles:")
            for key in CONVERSATION_FILES.keys():
                print(f"   - {key}")
            return None

    def show_discussion(self):
        """Afficher l'interface de sélection d'utilisateurs pour la discussion"""
        print("🔄 Ouverture de l'interface de discussion...")
        
        # Vérifier la connexion
        if not self.is_logged_in:
            messagebox.showerror("Erreur", "Vous devez être connecté pour accéder aux discussions")
            return
        
        if not self.drive_service:
            messagebox.showerror("Erreur", "Service Google Drive non disponible")
            return
        
        # Nettoyer l'interface actuelle
        for widget in self.main_frame.winfo_children():
            widget.destroy()
        
        # Changer le titre
        self.root.title(f"🚀 Magnetarr - Discussions ({self.current_user['username']})")
        
        # Configurer l'interface
        self.setup_discussion_interface()
    
    def setup_discussion_interface(self):
        """Configurer l'interface de sélection d'utilisateurs"""
        # Couleurs de l'interface
        bg_color = '#1a1a1a'
        header_color = '#2d2d2d'
        accent_color = '#00ff88'
        text_color = '#ffffff'
        button_color = '#4488ff'
        
        # Application des couleurs
        self.root.configure(bg=bg_color)
        self.main_frame.configure(bg=bg_color)
        
        # Header
        header = tk.Frame(self.main_frame, bg=header_color, height=50)
        header.pack(fill='x', padx=10, pady=10)
        header.pack_propagate(False)
        
        title_label = tk.Label(
            header,
            text="💬 ᴅɪꜱᴄᴜꜱꜱɪᴏɴꜱ - Sélection d'utilisateur",
            font=('Arial', 14, 'bold'),
            fg=accent_color,
            bg=header_color
        )
        title_label.pack(side='left', padx=15, pady=10)
        
        # Bouton retour
        back_btn = tk.Button(
            header,
            text="🏠 Menu",
            command=self.show_main_menu,
            bg='#666666',
            fg='white',
            font=('Arial', 10, 'bold'),
            relief='flat',
            padx=15,
            pady=5
        )
        back_btn.pack(side='right', padx=15, pady=10)
        
        # Zone principale
        main_area = tk.Frame(self.main_frame, bg=bg_color)
        main_area.pack(fill='both', expand=True, padx=20, pady=10)
        
        # Message d'instructions
        info_label = tk.Label(
            main_area,
            text="Sélectionnez un utilisateur avec lequel vous souhaitez discuter :",
            font=('Arial', 12),
            fg=text_color,
            bg=bg_color
        )
        info_label.pack(pady=(10, 20))
        
        # Frame pour les boutons utilisateurs
        users_frame = tk.Frame(main_area, bg=bg_color)
        users_frame.pack(fill='both', expand=True)
        
        # Charger et afficher les utilisateurs
        self.load_and_display_users(users_frame)
    
    def load_and_display_users(self, parent_frame):
        """Charger et afficher la liste des utilisateurs disponibles"""
        try:
            # Charger les utilisateurs depuis Google Drive
            users = self.load_users_from_drive()
            
            # Filtrer l'utilisateur actuel
            available_users = [user for user in users if user['username'] != self.current_user['username']]
            
            if not available_users:
                no_users_label = tk.Label(
                    parent_frame,
                    text="Aucun autre utilisateur disponible pour la discussion.",
                    font=('Arial', 12),
                    fg='#888888',
                    bg='#1a1a1a'
                )
                no_users_label.pack(pady=50)
                return
            
            # Container pour centrer les boutons utilisateurs
            container = tk.Frame(parent_frame, bg='#1a1a1a')
            container.pack(expand=True)
            
            # Créer un bouton pour chaque utilisateur
            for user in available_users:
                user_btn = tk.Button(
                    container,
                    text=f"💬 Discuter avec {user['username']}",
                    command=lambda u=user: self.open_chat_with_user(u),
                    bg='#4488ff',
                    fg='white',
                    font=('Arial', 12, 'bold'),
                    relief='flat',
                    width=30,
                    height=2,
                    cursor='hand2'
                )
                user_btn.pack(pady=10)
                
                # Afficher le rôle de l'utilisateur
                role_label = tk.Label(
                    container,
                    text=f"Rôle: {user.get('role', 'user')} | Email: {user.get('email', 'N/A')}",
                    font=('Arial', 10),
                    fg='#888888',
                    bg='#1a1a1a'
                )
                role_label.pack(pady=(0, 15))
                
        except Exception as e:
            print(f"❌ Erreur lors du chargement des utilisateurs: {e}")
            error_label = tk.Label(
                parent_frame,
                text="Erreur lors du chargement des utilisateurs.",
                font=('Arial', 12),
                fg='#ff4444',
                bg='#1a1a1a'
            )
            error_label.pack(pady=50)
    
    def open_chat_with_user(self, target_user):
        """Ouvrir l'interface de chat avec un utilisateur spécifique (version modifiée)"""
        print(f"🔄 Ouverture du chat avec {target_user['username']}...")
        
        self.current_chat_user = target_user
        
        # Vérifier qu'un fichier de conversation existe pour ces utilisateurs
        file_id = self.get_conversation_file_id()
        if not file_id:
            # Proposer de revenir en arrière
            result = messagebox.askyesno(
                "Fichier manquant",
                f"Aucun fichier de conversation configuré pour:\n"
                f"{self.current_user['username']} ↔ {target_user['username']}\n\n"
                f"Voulez-vous voir les instructions pour en créer un ?"
            )
            if result:
                self.show_file_creation_instructions()
            return
        
        # Nettoyer l'interface
        for widget in self.main_frame.winfo_children():
            widget.destroy()
        
        # Changer le titre
        self.root.title(f"🚀 Magnetarr - Chat avec {target_user['username']}")
        
        # Charger l'historique de conversation
        self.load_conversation_history()
        
        # Configurer l'interface de chat
        self.setup_chat_interface()

    def show_file_creation_instructions(self):
        """Afficher les instructions pour créer un fichier de conversation"""
        users = sorted([self.current_user['username'].lower(), self.current_chat_user['username'].lower()])
        key = f"{users[0]}_{users[1]}"
        
        instructions = f"""Instructions pour créer le fichier de conversation:

1. Allez sur Google Drive
2. Créez un nouveau fichier JSON vide
3. Nommez-le: conversation_{users[0]}_{users[1]}.json
4. Partagez-le avec l'email du Service Account
5. Copiez l'ID du fichier (dans l'URL)
6. Ajoutez cette ligne dans CONVERSATION_FILES:

    "{key}": "ID_DU_FICHIER",

7. Relancez l'application

Utilisateurs: {self.current_user['username']} ↔ {self.current_chat_user['username']}
"""
        
        messagebox.showinfo("Instructions", instructions)
    
    def load_conversation_history(self):
        """Charger l'historique de conversation depuis le fichier Google Drive"""
        try:
            file_id = self.get_conversation_file_id()
            
            if not file_id:
                # Aucun fichier configuré pour cette conversation
                self.chat_history = []
                messagebox.showwarning(
                    "Fichier manquant", 
                    f"Aucun fichier de conversation configuré pour:\n"
                    f"{self.current_user['username']} ↔ {self.current_chat_user['username']}\n\n"
                    f"Créez un fichier sur Google Drive et ajoutez son ID dans la configuration."
                )
                return
            
            print(f"🔄 Chargement de la conversation depuis le fichier: {file_id}")
            
            # Télécharger le contenu du fichier
            request = self.drive_service.files().get_media(fileId=file_id)
            file_content = request.execute()
            content_text = file_content.decode('utf-8').strip()
            
            if content_text and content_text != "":
                # Le fichier contient des données
                try:
                    conversation_data = json.loads(content_text)
                    self.chat_history = conversation_data.get('messages', [])
                    print(f"✅ {len(self.chat_history)} messages chargés")
                except json.JSONDecodeError:
                    # Le fichier n'est pas encore en format JSON valide
                    print("📝 Fichier vide ou format incorrect - Initialisation d'une nouvelle conversation")
                    self.chat_history = []
            else:
                # Fichier vide - nouvelle conversation
                print("📝 Fichier vide - Nouvelle conversation créée")
                self.chat_history = []
                    
        except Exception as e:
            print(f"❌ Erreur lors du chargement de la conversation: {e}")
            self.chat_history = []
            messagebox.showerror(
                "Erreur de chargement", 
                f"Impossible de charger la conversation:\n{e}\n\n"
                f"Vérifiez que le fichier existe et que les permissions sont correctes."
            )

    def save_conversation_to_drive(self):
        """Sauvegarder la conversation dans le fichier Google Drive existant"""
        try:
            file_id = self.get_conversation_file_id()
            
            if not file_id:
                messagebox.showerror(
                    "Erreur de sauvegarde", 
                    "Aucun fichier de conversation configuré.\n"
                    "Impossible de sauvegarder."
                )
                return
            
            print(f"💾 Sauvegarde de la conversation dans le fichier: {file_id}")
            
            # Préparer les données de conversation
            conversation_data = {
                "titre": f"Conversation entre {self.current_user['username']} et {self.current_chat_user['username']}",
                "participants": [
                    {
                        "username": self.current_user['username'],
                        "email": self.current_user.get('email', 'N/A'),
                        "role": self.current_user.get('role', 'user')
                    },
                    {
                        "username": self.current_chat_user['username'],
                        "email": self.current_chat_user.get('email', 'N/A'), 
                        "role": self.current_chat_user.get('role', 'user')
                    }
                ],
                "created_date": datetime.now().isoformat(),
                "last_updated": datetime.now().isoformat(),
                "total_messages": len(self.chat_history),
                "messages": self.chat_history
            }
            
            # Convertir en JSON formaté
            json_content = json.dumps(conversation_data, indent=2, ensure_ascii=False)
            
            # Mettre à jour le fichier existant
            media = MediaIoBaseUpload(
                BytesIO(json_content.encode('utf-8')), 
                mimetype='application/json'
            )
            
            self.drive_service.files().update(
                fileId=file_id,
                media_body=media
            ).execute()
            
            print("✅ Conversation sauvegardée avec succès sur Google Drive!")
                    
        except Exception as e:
            print(f"❌ Erreur lors de la sauvegarde: {e}")
            messagebox.showerror("Erreur", f"Impossible de sauvegarder la conversation:\n{e}")
            
            # Sauvegarde locale en cas d'échec
            try:
                self.save_conversation_locally()
            except:
                pass

    def save_conversation_locally(self):
        """Sauvegarde locale de secours"""
        try:
            # Créer un dossier local pour les sauvegardes
            local_folder = "conversations_backup"
            if not os.path.exists(local_folder):
                os.makedirs(local_folder)
            
            # Nom de fichier local
            users = sorted([self.current_user['username'], self.current_chat_user['username']])
            filename = f"conversation_{users[0]}_{users[1]}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            local_path = os.path.join(local_folder, filename)
            
            # Données à sauvegarder
            conversation_data = {
                "participants": [self.current_user['username'], self.current_chat_user['username']],
                "created_date": datetime.now().isoformat(),
                "messages": self.chat_history
            }
            
            # Écrire le fichier
            with open(local_path, 'w', encoding='utf-8') as f:
                json.dump(conversation_data, f, indent=2, ensure_ascii=False)
            
            print(f"💾 Sauvegarde locale créée: {local_path}")
            messagebox.showinfo(
                "Sauvegarde locale", 
                f"La conversation a été sauvegardée localement:\n{local_path}"
            )
            
        except Exception as e:
            print(f"❌ Erreur sauvegarde locale: {e}")
    
    def setup_chat_interface(self):
        """Configurer l'interface de chat"""
        # Couleurs de l'interface
        bg_color = '#1a1a1a'
        header_color = '#2d2d2d'
        chat_bg = '#0f0f0f'
        accent_color = '#00ff88'
        text_color = '#ffffff'
        
        # Application des couleurs
        self.root.configure(bg=bg_color)
        self.main_frame.configure(bg=bg_color)
        
        # Header
        header = tk.Frame(self.main_frame, bg=header_color, height=50)
        header.pack(fill='x', padx=5, pady=5)
        header.pack_propagate(False)
        
        title_label = tk.Label(
            header,
            text=f"💬 Chat avec {self.current_chat_user['username']}",
            font=('Arial', 14, 'bold'),
            fg=accent_color,
            bg=header_color
        )
        title_label.pack(side='left', padx=15, pady=10)
        
        # Boutons du header
        button_frame = tk.Frame(header, bg=header_color)
        button_frame.pack(side='right', padx=15, pady=8)
        
        # Bouton actualiser
        refresh_btn = tk.Button(
            button_frame,
            text="🔄",
            command=self.refresh_chat,
            bg='#4488ff',
            fg='white',
            font=('Arial', 10, 'bold'),
            relief='flat',
            width=3,
            height=1
        )
        refresh_btn.pack(side='right', padx=2)
        
        # Bouton retour
        back_btn = tk.Button(
            button_frame,
            text="🏠 Menu",
            command=self.show_main_menu,
            bg='#666666',
            fg='white',
            font=('Arial', 9, 'bold'),
            relief='flat',
            padx=10,
            pady=2
        )
        back_btn.pack(side='right', padx=5)
        
        # Zone de chat principale
        chat_frame = tk.Frame(self.main_frame, bg=bg_color)
        chat_frame.pack(fill='both', expand=True, padx=10, pady=5)
        
        # Zone d'affichage des messages
        self.chat_display = scrolledtext.ScrolledText(
            chat_frame,
            bg=chat_bg,
            fg=text_color,
            font=('Consolas', 11),
            wrap=tk.WORD,
            relief='flat',
            borderwidth=2,
            state='disabled',
            selectbackground='#333333'
        )
        self.chat_display.pack(fill='both', expand=True, pady=(0, 10))
        
        # Zone de saisie
        input_frame = tk.Frame(chat_frame, bg=bg_color, height=60)
        input_frame.pack(fill='x', pady=(0, 5))
        input_frame.pack_propagate(False)
        
        # Champ de saisie
        self.message_entry = tk.Entry(
            input_frame,
            font=('Arial', 11),
            bg='#2d2d2d',
            fg=text_color,
            insertbackground=text_color,
            relief='flat',
            bd=5
        )
        self.message_entry.pack(side='left', fill='both', expand=True, padx=(0, 10), pady=15)
        
        # Bouton d'envoi
        send_btn = tk.Button(
            input_frame,
            text="📤 Envoyer",
            command=self.send_message,
            bg='#00ff88',
            fg='#000000',
            font=('Arial', 11, 'bold'),
            relief='flat',
            padx=15,
            pady=8
        )
        send_btn.pack(side='right', pady=15)
        
        # Permettre l'envoi avec Entrée
        self.message_entry.bind('<Return>', lambda e: self.send_message())
        self.message_entry.focus()
        
        # Afficher l'historique de conversation
        self.display_chat_history()
    
    def send_message(self):
        """Envoyer un message"""
        message_text = self.message_entry.get().strip()
        
        if not message_text:
            return
        
        # Créer l'objet message
        message = {
            "sender": self.current_user['username'],
            "content": message_text,
            "timestamp": datetime.now().isoformat(),
            "date_formatted": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }
        
        # Ajouter à l'historique
        self.chat_history.append(message)
        
        # Afficher le message
        self.display_new_message(message)
        
        # Vider le champ de saisie
        self.message_entry.delete(0, tk.END)
        
        # Sauvegarder sur Google Drive
        threading.Thread(target=self.save_conversation_to_drive, daemon=True).start()
    
    def display_chat_history(self):
        """Afficher l'historique de chat"""
        self.chat_display.config(state='normal')
        self.chat_display.delete(1.0, tk.END)
        
        if not self.chat_history:
            self.chat_display.insert(tk.END, "💬 Début de la conversation...\n\n")
        else:
            for message in self.chat_history:
                self.display_message_in_chat(message)
        
        self.chat_display.config(state='disabled')
        self.chat_display.see(tk.END)
    
    def display_new_message(self, message):
        """Afficher un nouveau message"""
        self.chat_display.config(state='normal')
        self.display_message_in_chat(message)
        self.chat_display.config(state='disabled')
        self.chat_display.see(tk.END)
    
    def display_message_in_chat(self, message):
        """Afficher un message dans la zone de chat"""
        sender = message.get('sender', 'Inconnu')
        content = message.get('content', '')
        timestamp = message.get('date_formatted', '')
        
        # Formatage du message selon ton style demandé
        formatted_message = f"[ {sender} ] > {content}\n"
        
        self.chat_display.insert(tk.END, formatted_message)
        
        # Optionnel: ajouter l'horodatage en petit
        if timestamp:
            time_info = f"    {timestamp}\n\n"
            self.chat_display.insert(tk.END, time_info)
    
    def refresh_chat(self):
        """Actualiser le chat"""
        print("🔄 Actualisation du chat...")
        # Recharger la conversation depuis Google Drive
        self.load_conversation_history()
        # Réafficher l'historique
        self.display_chat_history()

# ===============================================
# GESTION DE LA CONSOLE
# ===============================================

    def show_console(self):
        """Transformer la fenêtre en console"""
        print("🔄 Ouverture de la console...")
        
        # Nettoyer complètement le contenu actuel
        for widget in self.main_frame.winfo_children():
            widget.destroy()
        
        # Changer le titre de la fenêtre
        self.root.title("🚀 Magnetarr - Console")
        
        # Réinitialiser les couleurs
        self.root.configure(bg='#1a1a1a')
        self.main_frame.configure(bg='#1a1a1a')
        
        # Créer l'interface console dans la même fenêtre
        self.setup_console_interface()
        
        # Lancer le script Google Drive
        threading.Thread(target=self.run_google_drive_script, daemon=True).start()
    
    def setup_console_interface(self):
        """Configurer l'interface console"""
        # Header
        header = tk.Frame(self.main_frame, bg='#2d2d2d', height=40)
        header.pack(fill='x', padx=5, pady=5)
        header.pack_propagate(False)
        
        title_label = tk.Label(
            header,
            text="🚀 ᴍᴀɢɴᴇᴛᴀʀʀ - Console",
            font=('Arial', 12, 'bold'),
            fg='#00ff88',
            bg='#2d2d2d'
        )
        title_label.pack(side='left', padx=10, pady=8)
        
        # Bouton retour au menu
        menu_btn = tk.Button(
            header,
            text="🏠 Menu",
            command=self.show_main_menu,
            bg='#666666',
            fg='white',
            font=('Arial', 9, 'bold'),
            relief='flat',
            padx=10,
            pady=2
        )
        menu_btn.pack(side='right', padx=10, pady=8)
        
        # Console principale
        console_frame = tk.Frame(self.main_frame, bg='#1a1a1a')
        console_frame.pack(fill='both', expand=True, padx=5, pady=5)
        
        self.console = scrolledtext.ScrolledText(
            console_frame,
            bg='#0a0a0a',
            fg='#00ff00',
            font=('Consolas', 10),
            insertbackground='#00ff00',
            selectbackground='#333333',
            wrap=tk.WORD,
            relief='flat',
            borderwidth=2,
            state='disabled'  # Rendre la console en lecture seule
        )
        self.console.pack(fill='both', expand=True)
        
        # Footer avec boutons
        footer = tk.Frame(self.main_frame, bg='#2d2d2d', height=50)
        footer.pack(fill='x', padx=5, pady=5)
        footer.pack_propagate(False)
        
        # Bouton fermer
        close_btn = tk.Button(
            footer,
            text="🔸 Fermer",
            command=self.on_closing,
            bg='#ff4444',
            fg='white',
            font=('Arial', 9, 'bold'),
            relief='flat',
            padx=15,
            pady=5
        )
        close_btn.pack(side='right', padx=10, pady=10)
        
        # Bouton actualiser
        refresh_btn = tk.Button(
            footer,
            text="🔄 Actualiser",
            command=self.refresh_console,
            bg='#4488ff',
            fg='white',
            font=('Arial', 9, 'bold'),
            relief='flat',
            padx=15,
            pady=5
        )
        refresh_btn.pack(side='right', padx=5, pady=10)
    
    def write_to_console(self, text):
        """Écrire dans la console"""
        if hasattr(self, 'console'):
            # Activer temporairement l'édition
            self.console.config(state='normal')
            self.console.insert(tk.END, text)
            self.console.see(tk.END)
            # Remettre en lecture seule
            self.console.config(state='disabled')
            self.root.update_idletasks()
    
    def refresh_console(self):
        """Actualiser la console et relancer le script"""
        if hasattr(self, 'console'):
            # Activer temporairement l'édition pour nettoyer
            self.console.config(state='normal')
            self.console.delete(1.0, tk.END)
            # Remettre en lecture seule
            self.console.config(state='disabled')
            self.write_to_console("🔄 Actualisation de la console...\n\n")
            
            # Relancer le script Google Drive en arrière-plan
            threading.Thread(target=self.run_google_drive_script, daemon=True).start()

# ===============================================
# GESTION GOOGLE DRIVE ET FONCTIONNALITÉS
# ===============================================

    def run_google_drive_script(self):
        """Exécuter le script Google Drive"""
        self.write_to_console("🚀 Initialisation du programme...\n")
        self.write_to_console("=" * 60 + "\n")
        
        try:
            # Vérifier si le service est déjà initialisé
            if not self.drive_service:
                # Connexion à Google Drive
                service = self.connect_to_drive()
            else:
                service = self.drive_service
            
            # Lister les fichiers
            self.list_drive_files(service, DOSSIER_PARTAGE_ID)
            
            self.write_to_console("=" * 60 + "\n")
            self.write_to_console("✅ Programme initialisé avec succès !\n")
            
        except FileNotFoundError:
            self.write_to_console(f"❌ Fichier de credentials non trouvé !\n")
            self.write_to_console(f"📁 Chemin: {SERVICE_ACCOUNT_FILE}\n")
            self.write_to_console("💡 Vérifiez le chemin du fichier JSON\n\n")
            
        except Exception as e:
            self.write_to_console(f"❌ Erreur: {str(e)}\n")
            self.write_to_console("💡 Vérifiez vos credentials et permissions\n\n")
        
        self.write_to_console("🔸 Console prête. Vous pouvez interagir avec le programme.\n")
    
    def connect_to_drive(self):
        """Se connecter à Google Drive"""
        self.write_to_console("🔗 Connexion à Google Drive...\n")
        
        scopes = ['https://www.googleapis.com/auth/drive']
        credentials = Credentials.from_service_account_file(SERVICE_ACCOUNT_FILE, scopes=scopes)
        service = build('drive', 'v3', credentials=credentials)
        
        # Sauvegarder le service pour réutilisation
        self.drive_service = service
        
        self.write_to_console("✅ Connecté à Google Drive avec succès !\n\n")
        return service
    
    def list_drive_files(self, service, dossier_id):
        """Lister les fichiers du dossier partagé"""
        self.write_to_console(f"📋 Analyse du dossier partagé...\n")
        
        try:
            query = f"'{dossier_id}' in parents and trashed=false"
            
            results = service.files().list(
                q=query,
                fields="files(id, name, mimeType, size, modifiedTime, owners)",
                orderBy="modifiedTime desc"
            ).execute()
            
            items = results.get('files', [])
            
            if not items:
                self.write_to_console("📂 Dossier vide - Prêt pour les premières discussions !\n\n")
                return
            
            self.write_to_console(f"📁 {len(items)} éléments trouvés :\n\n")
            
            # Séparer et afficher
            dossiers = [item for item in items if item['mimeType'] == 'application/vnd.google-apps.folder']
            fichiers = [item for item in items if item['mimeType'] != 'application/vnd.google-apps.folder']
            
            if dossiers:
                self.write_to_console("📂 DOSSIERS :\n")
                for dossier in dossiers:
                    self.write_to_console(f"   📁 {dossier['name']}\n")
            
            if fichiers:
                self.write_to_console("\n📄 FICHIERS DE DISCUSSION :\n")
                for fichier in fichiers[:10]:  # Limiter à 10 pour l'affichage
                    taille = fichier.get('size', 'N/A')
                    if taille and taille != 'N/A':
                        taille = f"{int(taille):,} bytes"
                    
                    self.write_to_console(f"   📄 {fichier['name']}\n")
                    self.write_to_console(f"      Taille: {taille}\n")
                
                if len(fichiers) > 10:
                    self.write_to_console(f"   ... et {len(fichiers) - 10} autres fichiers\n")
            
            self.write_to_console("\n")
                
        except Exception as e:
            self.write_to_console(f"❌ Erreur lors de l'analyse: {e}\n\n")

    def check_conversation_files_config(self):
        """Vérifier que tous les fichiers de conversation sont accessibles"""
        print("🔍 Vérification des fichiers de conversation...")
        
        for key, file_id in CONVERSATION_FILES.items():
            try:
                # Tenter d'accéder au fichier
                file_info = self.drive_service.files().get(fileId=file_id, fields="name,id,parents").execute()
                print(f"✅ {key}: {file_info.get('name')} (ID: {file_id})")
            except Exception as e:
                print(f"❌ {key}: Erreur d'accès au fichier {file_id} - {e}")
        
        print("🔍 Vérification terminée.")

# ===============================================
# GESTION GÉNÉRALE ET FERMETURE
# ===============================================

    def on_closing(self):
        """Gérer la fermeture du programme"""
        self.root.quit()
        self.root.destroy()
    
    def run(self):
        """Lancer le programme"""
        self.root.mainloop()

# ===============================================
# POINT D'ENTRÉE DU PROGRAMME
# ===============================================

def main():
    """Fonction principale"""
    print("🚀 Démarrage du programme Magnetarr...")
    
    try:
        # Créer et lancer l'application
        app = MagnetarrApp()
        app.run()
        
    except KeyboardInterrupt:
        print("\n⚠️ Arrêt demandé par l'utilisateur")
        sys.exit(0)
    except Exception as e:
        print(f"❌ Erreur critique: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()








